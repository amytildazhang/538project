zeros.idx = which(z == 0)
random.unif[zeros.idx]
errors.idx = which(z - y != 0)
random.unif[errors.idx]
#iii
mus = vector(mode="numeric", length = n)
mus[alpha.1.idx] = 0
mus[alpha.2.idx] = -1
mus[alpha.3.idx] = 1
sigma = vector(mode="numeric", length = n)
sigma[alpha.1.idx] = 2
sigma[alpha.2.idx] = 1
sigma[alpha.3.idx] = sqrt(2)
sample = rnorm(n, mean = mus, sd = sigma)
######################################################
#Initial values
alpha = c(0.4, 0.3, 0.3)
mus = c(-1,0,1)
sigma = c(1,1,1)
##h(i,j)
##em = function(alpha, mus, sigma) {
loglik = c(0,0)
h.t = matrix(nrow = n, ncol = 3)
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
while( abs(loglik[1] - loglik[2]) >= 0.0001) {
for (i in 1:n){
for (j in 1:3) {
denom = dnorm(sample[i], mean = mus[1], sd = sigma[1])*alpha[1] + dnorm(sample[i], mean = mus[2], sd = sigma[2])*alpha[2] + dnorm(sample[i], mean = mus[3], sd = sigma[3])*alpha[3]
h.t[i,j] = dnorm(sample[i], mean = mus[j], sd = sigma[j])*alpha[j]/denom
}
}
##mu.hat(t+1)
for (j in 1:3){
mus[j] = sum(h.t[,j]*sample)/sum(h.t[,j])
sigma[j] = sum(h.t[,j]*(sample - mus[j])^2)/sum(h.t[,j])
alpha[j] = sum(h.t[,j])/n
}
loglik[1] = loglik[2]
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
}
#}
##em(alpha = alpha, mus = mus, sigma = sigma)
alpha
mus
sigma
#i 1000 random samples
n = 1000 #num samples
random.unif = runif(n)
#ii
alpha.1.idx = which(random.unif < 0.5)
alpha.2.idx = which(random.unif >= 0.5 & random.unif < 0.7)
alpha.3.idx = which(random.unif >= 0.7)
z = vector(mode="numeric", length = n)
z[alpha.1.idx] = 1
z[alpha.2.idx] = 2
z[alpha.3.idx] = 3
zeros.idx = which(z == 0)
random.unif[zeros.idx]
errors.idx = which(z - y != 0)
random.unif[errors.idx]
#iii
mus = vector(mode="numeric", length = n)
mus[alpha.1.idx] = 0
mus[alpha.2.idx] = -1
mus[alpha.3.idx] = 1
sigma = vector(mode="numeric", length = n)
sigma[alpha.1.idx] = 2
sigma[alpha.2.idx] = 1
sigma[alpha.3.idx] = sqrt(2)
sample = rnorm(n, mean = mus, sd = sigma)
######################################################
#Initial values
alpha = c(0.4, 0.3, 0.3)
mus = c(-1,0,1)
sigma = c(1,1,1)
##h(i,j)
##em = function(alpha, mus, sigma) {
loglik = c(0,0)
h.t = matrix(nrow = n, ncol = 3)
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
while( abs(loglik[1] - loglik[2]) >= 0.0001) {
for (j in 1:3) {
h.t[,j] = dnorm(sample, mean = mus[j], sd = sigma[j])*alpha[j]/(dnorm(sample, mean = mus[1], sd = sigma[1])*alpha[1] + dnorm(sample, mean = mus[2], sd = sigma[2])*alpha[2] + dnorm(sample, mean = mus[3], sd = sigma[3])*alpha[3])
}
##mu.hat(t+1)
for (j in 1:3){
mus[j] = sum(h.t[,j]*sample)/sum(h.t[,j])
sigma[j] = sum(h.t[,j]*(sample - mus[j])^2)/sum(h.t[,j])
alpha[j] = sum(h.t[,j])/n
}
loglik[1] = loglik[2]
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
}
#}
##em(alpha = alpha, mus = mus, sigma = sigma)
alpha
mus
sigma
#i 1000 random samples
n = 1000 #num samples
random.unif = runif(n)
#ii
alpha.1.idx = which(random.unif < 0.5)
alpha.2.idx = which(random.unif >= 0.5 & random.unif < 0.7)
alpha.3.idx = which(random.unif >= 0.7)
z = vector(mode="numeric", length = n)
z[alpha.1.idx] = 1
z[alpha.2.idx] = 2
z[alpha.3.idx] = 3
zeros.idx = which(z == 0)
random.unif[zeros.idx]
errors.idx = which(z - y != 0)
random.unif[errors.idx]
#iii
mus = vector(mode="numeric", length = n)
mus[alpha.1.idx] = 0
mus[alpha.2.idx] = -1
mus[alpha.3.idx] = 1
sigma = vector(mode="numeric", length = n)
sigma[alpha.1.idx] = 2
sigma[alpha.2.idx] = 1
sigma[alpha.3.idx] = sqrt(2)
sample = rnorm(n, mean = mus, sd = sigma)
######################################################
#Initial values
alpha = c(0.4, 0.3, 0.3)
mus = c(-1,0,1)
sigma = c(1,10,1)
##h(i,j)
##em = function(alpha, mus, sigma) {
loglik = c(0,0)
h.t = matrix(nrow = n, ncol = 3)
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
while( abs(loglik[1] - loglik[2]) >= 0.0001) {
for (j in 1:3) {
h.t[,j] = dnorm(sample, mean = mus[j], sd = sigma[j])*alpha[j]/(dnorm(sample, mean = mus[1], sd = sigma[1])*alpha[1] + dnorm(sample, mean = mus[2], sd = sigma[2])*alpha[2] + dnorm(sample, mean = mus[3], sd = sigma[3])*alpha[3])
}
##mu.hat(t+1)
for (j in 1:3){
mus[j] = sum(h.t[,j]*sample)/sum(h.t[,j])
sigma[j] = sum(h.t[,j]*(sample - mus[j])^2)/sum(h.t[,j])
alpha[j] = sum(h.t[,j])/n
}
loglik[1] = loglik[2]
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
}
#}
##em(alpha = alpha, mus = mus, sigma = sigma)
alpha
mus
sigma
#i 1000 random samples
n = 1000 #num samples
random.unif = runif(n)
#ii
alpha.1.idx = which(random.unif < 0.5)
alpha.2.idx = which(random.unif >= 0.5 & random.unif < 0.7)
alpha.3.idx = which(random.unif >= 0.7)
z = vector(mode="numeric", length = n)
z[alpha.1.idx] = 1
z[alpha.2.idx] = 2
z[alpha.3.idx] = 3
zeros.idx = which(z == 0)
random.unif[zeros.idx]
errors.idx = which(z - y != 0)
random.unif[errors.idx]
#iii
mus = vector(mode="numeric", length = n)
mus[alpha.1.idx] = 0
mus[alpha.2.idx] = -1
mus[alpha.3.idx] = 1
sigma = vector(mode="numeric", length = n)
sigma[alpha.1.idx] = 2
sigma[alpha.2.idx] = 1
sigma[alpha.3.idx] = sqrt(2)
sample = rnorm(n, mean = mus, sd = sigma)
######################################################
#Initial values
alpha = c(0.4, 0.3, 0.3)
mus = c(-1,0,1)
sigma = c(1,11,1)
##h(i,j)
##em = function(alpha, mus, sigma) {
loglik = c(0,0)
h.t = matrix(nrow = n, ncol = 3)
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
while( abs(loglik[1] - loglik[2]) >= 0.0001) {
for (j in 1:3) {
h.t[,j] = dnorm(sample, mean = mus[j], sd = sigma[j])*alpha[j]/(dnorm(sample, mean = mus[1], sd = sigma[1])*alpha[1] + dnorm(sample, mean = mus[2], sd = sigma[2])*alpha[2] + dnorm(sample, mean = mus[3], sd = sigma[3])*alpha[3])
}
##mu.hat(t+1)
for (j in 1:3){
mus[j] = sum(h.t[,j]*sample)/sum(h.t[,j])
sigma[j] = sum(h.t[,j]*(sample - mus[j])^2)/sum(h.t[,j])
alpha[j] = sum(h.t[,j])/n
}
loglik[1] = loglik[2]
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
}
#}
##em(alpha = alpha, mus = mus, sigma = sigma)
alpha
mus
sigma
#i 1000 random samples
n = 1000 #num samples
random.unif = runif(n)
#ii
alpha.1.idx = which(random.unif < 0.5)
alpha.2.idx = which(random.unif >= 0.5 & random.unif < 0.7)
alpha.3.idx = which(random.unif >= 0.7)
z = vector(mode="numeric", length = n)
z[alpha.1.idx] = 1
z[alpha.2.idx] = 2
z[alpha.3.idx] = 3
zeros.idx = which(z == 0)
random.unif[zeros.idx]
errors.idx = which(z - y != 0)
random.unif[errors.idx]
#iii
mus = vector(mode="numeric", length = n)
mus[alpha.1.idx] = 0
mus[alpha.2.idx] = -1
mus[alpha.3.idx] = 1
sigma = vector(mode="numeric", length = n)
sigma[alpha.1.idx] = 2
sigma[alpha.2.idx] = 1
sigma[alpha.3.idx] = sqrt(2)
sample = rnorm(n, mean = mus, sd = sigma)
######################################################
#Initial values
alpha = c(0.5, 0.2, 0.3)
mus = c(-1,0,1)
sigma = c(2,1,1)
##h(i,j)
##em = function(alpha, mus, sigma) {
loglik = c(0,0)
h.t = matrix(nrow = n, ncol = 3)
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
while( abs(loglik[1] - loglik[2]) >= 0.0001) {
for (j in 1:3) {
h.t[,j] = dnorm(sample, mean = mus[j], sd = sigma[j])*alpha[j]/(dnorm(sample, mean = mus[1], sd = sigma[1])*alpha[1] + dnorm(sample, mean = mus[2], sd = sigma[2])*alpha[2] + dnorm(sample, mean = mus[3], sd = sigma[3])*alpha[3])
}
##mu.hat(t+1)
for (j in 1:3){
mus[j] = sum(h.t[,j]*sample)/sum(h.t[,j])
sigma[j] = sum(h.t[,j]*(sample - mus[j])^2)/sum(h.t[,j])
alpha[j] = sum(h.t[,j])/n
}
loglik[1] = loglik[2]
loglik[2] = sum(alpha[1]*(log(alpha[1]) + dnorm(sample, mus[1], sigma[1], log = TRUE)) + alpha[2]*(log(alpha[2]) + dnorm(sample, mus[2], sigma[2], log = TRUE)) + alpha[3]*(log(alpha[3]) + dnorm(sample, mus[3], sigma[3], log = TRUE)))
}
#}
##em(alpha = alpha, mus = mus, sigma = sigma)
alpha
mus
sigma
n = 1000 #num samples
random.unif = runif(n)
alpha.1.idx = which(random.unif < 0.5)
alpha.2.idx = which(random.unif >= 0.5 & random.unif < 0.7)
alpha.3.idx = which(random.unif >= 0.7)
z = vector(mode="numeric", length = n)
z[alpha.1.idx] = 1
z[alpha.2.idx] = 2
z[alpha.3.idx] = 3
zeros.idx = which(z == 0)
random.unif[zeros.idx]
?random.unif
data.statepollsters = split(data.states, data.states$Poll, drop=TRUE)
library(stringr)
library(ggplot2)
today = as.Date("2012/10/14")
as.numeric.factor <- function(x) {as.numeric(levels(x))[x]}
#Dataset and description of data can be found at
#https://github.com/fivethirtyeight/data/tree/master/pollster-ratings
polls = read.csv("https://raw.githubusercontent.com/fivethirtyeight/data/master/pollster-ratings/raw-polls.tsv", header=TRUE, sep="\t")
polls = polls[grep(pattern = ".*Pres.*", x=polls$race),]
polls$polldate = as.Date(polls$polldate, format='%m/%d/%Y')
polls$electiondate = as.Date(polls$electiondate, format='%m/%d/%Y')
poll.ratings =  read.csv("https://raw.githubusercontent.com/fivethirtyeight/data/master/pollster-ratings/pollster-ratings.tsv", header=TRUE, sep="\t")
head(poll.ratings)
nat.polls2012 = read.csv("2012_poll_data.csv", header=TRUE, sep="\t")
state.polls2012 = read.csv("2012_poll_data_states.csv", header=TRUE, sep='\t')
nat.polls2012$State = "USA"
polls2012 = rbind(nat.polls2012, state.polls2012)
setwd("~/Box Sync/Fall 2015/511 Regression Analysis/538project")
library(stringr)
library(ggplot2)
today = as.Date("2012/10/14")
as.numeric.factor <- function(x) {as.numeric(levels(x))[x]}
#Dataset and description of data can be found at
#https://github.com/fivethirtyeight/data/tree/master/pollster-ratings
polls = read.csv("https://raw.githubusercontent.com/fivethirtyeight/data/master/pollster-ratings/raw-polls.tsv", header=TRUE, sep="\t")
polls = polls[grep(pattern = ".*Pres.*", x=polls$race),]
polls$polldate = as.Date(polls$polldate, format='%m/%d/%Y')
polls$electiondate = as.Date(polls$electiondate, format='%m/%d/%Y')
poll.ratings =  read.csv("https://raw.githubusercontent.com/fivethirtyeight/data/master/pollster-ratings/pollster-ratings.tsv", header=TRUE, sep="\t")
head(poll.ratings)
nat.polls2012 = read.csv("2012_poll_data.csv", header=TRUE, sep="\t")
state.polls2012 = read.csv("2012_poll_data_states.csv", header=TRUE, sep='\t')
nat.polls2012$State = "USA"
polls2012 = rbind(nat.polls2012, state.polls2012)
#format dates
dates = str_split_fixed(as.character(polls2012$Date), " - ", 2)
polls2012$StartDate = as.Date(paste("2012", dates[,1], sep="/"))
polls2012$EndDate = as.Date(paste("2012", dates[,2], sep="/"))
polls2012$Date = floor(rowMeans(matrix(c(polls2012$StartDate, polls2012$EndDate), ncol=2)))
polls2012$Date = as.Date(polls2012$Date, origin="1970-01-01")
#format "spread"
polls2012$Spread = as.character(polls2012$Spread)
spread = str_split_fixed(polls2012$Spread, " ", 2)
obama = which(spread[,1] == "Obama")
polls2012$Spread[obama] = as.numeric(spread[obama,2])
polls2012$Spread[-obama] = -as.numeric(spread[-obama,2])
polls2012$Spread[which(is.na(polls2012$Spread))] = 0
polls2012$Spread = as.numeric(polls2012$Spread)
#format sample
polls2012$Sample = as.character(polls2012$Sample)
sample = str_split_fixed(polls2012$Sample, " ", 2)
polls2012$Type = sample[,2]
polls2012$Sample = as.numeric(sample[,1])
head(polls2012)
head(polls)
summary(polls)
#Useful groupings within "polls"
state.polls = which(polls$location != 'US')
polls2000 = which(polls$year == 2000)
polls2004 = which(polls$year == 2004)
polls2008 = which(polls$year == 2008)
#polls2012 = which(polls$year == 2012 & polls$polldate < today & polls$type_simple == 'Pres-G')
partisan = which(polls$partisan != '') #these pollsters should be excluded later
head(state.polls)
############################
#Weighted polling average
############################
#http://fivethirtyeight.com/features/how-fivethirtyeight-calculates-pollster-ratings/#fn-31
#find pollster-induced error
polls.beforetoday = which(polls2012$EndDate < today)
polldata = polls2012[polls.beforetoday,]
polldata$Poll = factor(polldata$Poll, levels=levels(poll.ratings$Pollster))
nax = which(is.na(polldata$Poll))
polldata = polldata[-nax,] #take out polls that haven't been rated by 538
#Calculating recency
#http://fivethirtyeight.com/features/how-the-fivethirtyeight-senate-forecast-model-works/#fn-13
daysfrom = as.numeric(difftime(as.Date("2012/11/01"), today, unit='days'))
recencyrate = log(2)/(14 + 0.2*daysfrom)
timedif = as.numeric(difftime(today, polldata$Date))
polldata$recency = exp(-recencyrate * timedif)
#Reason-Rupe/PSRAI = Princeton...
#RCP Average = real clear politics average
#
polldata$rating = NA
for (i in 1:length(poll.ratings$Polls)){
pollster = poll.ratings$Pollster[i]
idx = which(polldata$Poll == pollster)
polldata$rating[idx] = poll.ratings$Predictive.Plus.Minus[i]
}
polldata$Sample[which(is.na(polldata$Sample))] = 600 #538 policy
##########################
##Likely Voter adjustment
##########################
rv = which(polldata$Type == "RV")
polldata$spread[rv] = polldata$spread[rv] - 2.7
#registered voter polls tend to differ from likely voter polls by 2.7 percentage points
##########################
##Trend Line Adjustment
##########################
#Create "week" variable
#Week is defined using "today"
polldata$Week = today - 7*floor(difftime(today, polldata$Date, unit='days')/7)
polldata$week = as.numeric(floor(difftime(today, polldata$Date, unit='days')/7))
fit = lm(Spread ~ State*Poll + factor(Week), data=polldata)
data.states = split(polldata, polldata$State, drop=TRUE)
data.statepollsters = split(data.states, data.states$Poll, drop=TRUE)
which(is.na(data.states))
data.states[1]
s = data.states[1]
s
s$AR
s = s$AR
s$Poll
s = data.states
s$AR
s$USA
?split
polldata$StatePollster = polldata$State*polldata$Poll
polldata$StatePollster = paste(polldata$State,polldata$Poll)
data.states = split(polldata, polldata$StatePollster, drop=TRUE)
?list
data.states[1]
length(data.states)
data.states[1]$`AR Hendrix College`
factors(data.states)
factor(data.states)
?complete.cases
?loess
loess.fits = lapply(data.states, function(xdf) {
loess(Spread ~ week, data=xdf, span=0.85)
summary(loess)
})
loess.fits = lapply(data.states, function(xdf) {
print(xdf)
loess(Spread ~ week, data=xdf, span=0.85)
summary(loess)
})
a = NA
loess.fits = lapply(data.states, function(xdf) {
a = xdf
print(xdf)
loess(Spread ~ week, data=xdf, span=0.85)
summary(loess)
})
a
xdf
a = NA
loess.fits = lapply(data.states, function(xdf) {
a = xdf
print(xdf)
loess(Spread ~ week, data=xdf, span=0.85)
summary(loess)
})
a
?loess
levels(polldata$StatePollster)
factor(polldata$StatePollster)
statepollsters = levels(factor(polldata$StatePollster))
statepollsters
loess.fits = rep(NA, length(statepollsters))
?subset
loess.fits = rep(NA, length(statepollsters))
for (i in 1:length(statepollsters)) {
loess.fits[i] = loess(Spread ~ week, data=polldata, subset=subset(polldata, polldata$StatePollster == statepollsters[i]))
}
loess.fits = lapply(data.states, function(xdf) {
traceback()
statepollsters[1]
loess(Spread ~ week, data=polldata, subset=subset(polldata, polldata$StatePollster == statepollsters[1]))
subset(polldata, polldata$StatePollster == statepollsters[1])
for (i in 1:length(statepollsters)) {
newdata = subset(polldata, polldata$StatePollster == statepollsters[i])
loess.fits[i] = loess(Spread ~ week, data=newdata)
}
for (i in 1:length(statepollsters)) {
newdata = subset(polldata, polldata$StatePollster == statepollsters[i])
loess.fits[i] = loess(Spread ~ week, data=newdata, span=0.85)
}
loess.fits = rep(NA, length(statepollsters))
for (i in 1:length(statepollsters)) {
newdata = subset(polldata, polldata$StatePollster == statepollsters[i])
print(length(newdata$Poll))
loess.fits[i] = loess(Spread ~ week, data=newdata, span=0.85)
}
subsets = rep(NA, length(statepollsters))
for (i in 1:length(statepollsters)) {
subsets[i] = subset(polldata, polldata$StatePollster == statepollsters[i])
}
loess.fits = lapply(data.states, function(xdf) {
warnings()
subsets
subsets[1]
statepollsters = as.character(levels(factor(polldata$StatePollster)))
subsets = rep(NA, length(statepollsters))
for (i in 1:length(statepollsters)) {
subsets[i] = subset(polldata, polldata$StatePollster == statepollsters[i])
}
subsets[1]
statepollsters
?lapply
loess.fits = rep(NA, length(statepollsters))
subsets = rep(NA, length(statepollsters))
for (i in 1:length(statepollsters)) {
subsets[i] = subset(polldata, polldata$StatePollster == statepollsters[i])
}
subsets = rep(NA, length(statepollsters))
for (i in 1:length(statepollsters)) {
subsets[i] = subset(polldata, polldata$StatePollster == statepollsters[i])
print(subsets[i])
}
?subset
head(polldata)
for (i in 1:length(statepollsters)) {
subsets[i] = subset(polldata, polldata$StatePollster == statepollsters[i], select=c(Spread, week, StatePollster))
print(subsets[i])
}
subsets[1]
head(polldata)
subsets = rep(NA, length(statepollsters))
for (i in 1:length(statepollsters)) {
subsets[i] = subset(polldata, polldata$StatePollster == statepollsters[i], select=c(Spread, StatePollster))
print(subsets[i])
}
housefx.fit = lm(Spread ~ State*Poll, data=polldata)
summary(housefx.fit)
housefx.fit$coefficients
nax = which(is.na(housefx.fit$coefficients) )
nax
housefx.fit$coefficients[-nax]
subsets = rep(NA, length(statepollsters))
for (i in 1:length(statepollsters)) {
newdata = subset(polldata, polldata$StatePollster == statepollsters[i], select=c(Spread, StatePollster))
loess(Spread ~ week, data=newdata)
print(subsets[i])
}
head(polldata)
loess.fits = rep(NA, length(statepollsters))
subsets = rep(NA, length(statepollsters))
for (i in 1:length(statepollsters)) {
newdata = subset(polldata, polldata$StatePollster == statepollsters[i], select=c(Spread, week, StatePollster))
loess(Spread ~ week, data=newdata)
print(subsets[i])
}
